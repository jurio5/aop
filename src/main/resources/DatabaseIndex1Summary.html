# 인덱스 정리

## 1. 인덱스가 필요한 이유

- 데이터가 적을 땐 빠르지만, 수십만~수억 건이 되면 `풀 테이블 스캔(Full Table Scan)`으로 인해 검색 성능이 급격히 저하됨.
- 풀 테이블 스캔의 시간 복잡도: **O(n)**
- 예시: 1억 건 데이터에서 단일 검색 시 수십 초 이상 소요 가능.
-  해결책: **인덱스(Index)**

- **인덱스 활용**
- WHERE 절에 자주 쓰이는 컬럼에는 인덱스를 반드시 생성해야 함.
- 서비스 핵심 쿼리에서 풀 테이블 스캔이 나오지 않도록 설계하는 것이 필수.

- **실행 계획 확인 (`EXPLAIN`)**
- 의도치 않은 풀 테이블 스캔이 발생하는지 반드시 점검.
- `type: ALL` → 풀 테이블 스캔 경고 신호.

- **작업 시간 분리**
- 통계/배치 같은 대용량 전체 스캔은 이용자가 적은 새벽 시간대에 수행.

## 2. 인덱스의 개념

- 책의 **찾아보기(색인)** 과 동일한 개념.
- 특정 컬럼 값 + 해당 데이터의 위치를 저장하는 별도의 자료 구조.
- `ex) item_name (정렬 상태) + item_id (실제로는 참조하는 테이블이랑 연결되어 있는 레퍼런스 값) -> item_name 조회 시 item_id를 기준으로 조회하기에 속도 향상`
- 항상 **정렬된 상태** 유지.
- 검색 속도를 **O(log n)** 수준으로 향상.
#### 클러스터 인덱스 (Clustered Index)

- **기본 키(PK)** 기준으로 자동 생성되는 인덱스
- **테이블 데이터 자체가 인덱스에 포함되어 있음**
- 즉, 클러스터 인덱스 = 데이터 자체가 정렬된 구조
- 장점:
- PK 기반 검색은 매우 빠름 → 인덱스 탐색 = 곧 데이터 조회
- 단점:
- PK 값이 바뀌면 데이터 재배치 필요 (비효율적)
- 테이블당 **하나만 존재** (데이터 자체가 정렬되어 있어야 하므로)

```sql
CREATE TABLE users (
id BIGINT PRIMARY KEY AUTO_INCREMENT,  -- PK → 클러스터 인덱스 자동 생성
email VARCHAR(255) UNIQUE,
name VARCHAR(100)
);
```

#### 보조 인덱스 (Secondary Index, Non-Clustered Index)

- PK 외의 컬럼에 사용자가 직접 만든 인덱스
- 원본 데이터 대신 **PK 값을 저장**해서, PK 인덱스를 다시 타고 원본 데이터 접근
- 장점:
- PK 외 컬럼 검색 속도 개선
- 단점:
- 두 번 탐색 필요 (보조 인덱스 → PK 인덱스 → 원본 데이터)
- 따라서 PK가 길면 보조 인덱스도 크기가 커짐
```sql
-- email 컬럼에 보조 인덱스 생성
CREATE INDEX idx_users_email ON users(email);
```

#### 클러스터 vs 보조 인덱스 비교

| 구분    | 클러스터 인덱스              | 보조 인덱스          |
| ----- | --------------------- | --------------- |
| 생성    | 자동 (PK 기반)            | 수동 (사용자가 지정)    |
| 저장 내용 | PK + 실제 데이터           | 인덱스 컬럼 값 + PK 값 |
| 검색 속도 | 빠름 (한 번 탐색)           | PK까지 두 번 탐색     |
| 개수    | 테이블당 1개               | 여러 개 가능         |
| 쓰기 비용 | 상대적으로 높음 (데이터 재배치 필요) | PK 갱신 영향 받음     |
#### 실무 팁

- **PK는 신중히 선택**: 단순하고 짧은 정수형이 이상적 (BIGINT AUTO_INCREMENT)
- 보조 인덱스는 PK 값을 참조하므로 **PK가 길면 보조 인덱스 크기도 비대해짐**
- → UUID 같은 긴 문자열을 PK로 두면 비효율적
- 자주 조회하는 조건 컬럼에는 보조 인덱스 생성
- 자주 쓰기(INSERT/UPDATE/DELETE) 되는 테이블에는 인덱스 개수를 최소화
#### 정리

- **클러스터 인덱스 = 테이블 데이터 자체를 정렬한 구조 (PK 기준, 단 하나)**
- **보조 인덱스 = 추가 색인, 결국 PK 인덱스를 경유해야 원본 데이터 조회**
## 3. 인덱스의 내부 구조

- 기본적으로 **트리(Tree) 구조** 사용.
- 주요 원리:
- **이진 탐색 트리**: 좌측은 작은 값, 우측은 큰 값 → 탐색 속도 `O(log n)`
- 다만, 값이 한 쪽으로 기울어진다면(`ex)1,5,6,10,15`) 이진 탐색 트리가 편향 트리가 되면서 최악의 경우 `o(n)`의 성능이 나오고, 이는 `풀 테이블 스캔`과 동일한 성능이 된다.
- **밸런스 트리(Balanced Tree)**: 한쪽으로 치우치는 문제 해결
- 위 와 같은 문제를 해결하기 위해 RDBMS 는 내부에서 밸런스 트리 구조를 사용하여 균형을 유지하기에 최악의 경우에도 동일하게 `o(log n)`성능이 나오게 된다.
- 실제 DBMS는 **B-Tree / B+Tree** 사용 → 디스크 I/O 최소화, 대용량 데이터 최적화

## 인덱스 생성/관리

- 인덱스 이름은 보통 `idx_테이블명_컬럼명`과 같은 규칙으로 지으면 관리하기 편하다.

- 생성:
```sql
CREATE INDEX idx_items_item_name ON items (item_name);
```

- 조회:
```sql
SHOW INDEX FROM items;
```

- 삭제:
```sql
DROP INDEX idx_items_item_name ON items;
```

- 결과:
`SHOW INDEX`를 통해 확인할 수 있는 `카디널리티(Cardinality)`는 인덱스 컬럼의 **서로 다른 값이 몇 개 정도 있는지를 나타내는 통계 정보**이다. 값이 다양할수록(카디널리티가 높을수록) 인덱스를 사용한 검색 시 더 많은 레코드를 걸러낼 수 있어 효율이 높아진다. 단, MySQL이 보여주는 카디널리티는 실제 정확한 값이 아니라 **옵티마이저가 참고하는 추정치**이므로, 필요시 `ANALYZE TABLE` 명령으로 최신 통계로 갱신할 수 있다.

- 인덱스가 자동 생성되는 경우:
- **PRIMARY KEY**, **FOREIGN KEY**, **UNIQUE 제약조건**

- `UNIQUE` 제약조건이 있는 컬럼에는 자동으로 인덱스가 생성되는 이유는 예를 들어, 핸드폰 번호 컬럼에 10만 건의 데이터가 있을 때, 새로운 데이터를 추가하려면 이 값이 이미 존재하는지 확인해야 한다. 만약 `UNIQUE` 제약조건이 없다면 매번 전체 데이터를 조회해야 하므로 성능 문제가 발생할 수 있다. 따라서 유일성 검사를 효율적으로 수행하고 성능을 보장하기 위해 `UNIQUE` 제약조건에는 자동으로 인덱스가 생성된다.
- 요약을 하자면 `UNIQUE` 제약조건에는 데이터 유일성 검사를 빠르게 하기 위해 자동으로 인덱스가 생성된다.

## 인덱스 성능 확인

- `EXPLAIN` 키워드로 실행 계획 확인 가능.
- `type: ALL` → 풀 테이블 스캔
- `type: ref` → 동등 비교 인덱스 사용
- `type: range` → 범위 검색 인덱스 사용
- `key` 컬럼에서 사용된 인덱스 확인 가능
- `key` 값이 `NULL`이라면 인덱스를 사용하지 못했다는 의미

## 인덱스 동작 방식

### 동등 비교 (=, JOIN)

- 인덱스 사용 시 `type: ref`
- 풀 테이블 스캔(`ALL`) 대신 필요한 데이터만 탐색
### 범위 검색 (BETWEEN, >, <, LIKE 등)

- 인덱스 사용 시 `type: range`
- 조건에 맞는 데이터 범위만 인덱스 스캔
### LIKE 검색

- `%keyword` → 인덱스 사용 불가 (앞에 와일드카드 있을 때)
- `keyword%` → 인덱스 사용 가능
- 만약 `%keyword%`처럼 중간에 `keyword`가 포함되는 글자를 찾고싶다면 `전문 검색(Full-Text Search)`라는 특수한 기능을 사용해야한다. (`MATCH ... AGAINST`)
- 혹은 `엘라스틱 서치`같은 검색을 중심으로 한 분산형 NoSQL 데이터베이스를 사용하는 것도 방법이다.
### 정렬 (ORDER BY)

- 정렬 대상 컬럼에 인덱스 있으면 **추가 정렬 불필요**
- 이미 인덱스 작업을 하는 순간 내부적으로 정렬이 되어있는 상태라 데이터베이스는 테이블의 순서를 알고 있는 상태여서 추가적인 정렬이 불필요
- 없으면 DB가 정렬 작업 수행 → 성능 저하
- 인덱스를 통해 정렬되어 있는 내용이 아니라면 전체적으로 한 번 정렬을 한 뒤에 정렬 작업을 한 번 더 수행하기에 성능 저하
- 그러나 베스트 프랙티스는 항상 `ORDER BY`를 명시해주는게 좋음
- 인덱스를 드롭하거나, 새로운 인덱스가 추가될 때 순서를 보장할 수 없기 때문
- 인덱스를 양방향으로 정렬할 수 있기 때문에 `filesort` 작업이 일어나지 않은 상태로 `내림차순`이 가능하다.
- 혹은 인덱스를 생성할 때 `price`가 내림차순으로 많이 사용되는 컬럼이라면 내림차순으로 설정해도 된다. (`Backward index scan`)
- `ex) create index idx_items_price on items (price desc)`
- 이렇게 내림차순을 지정하는 이유는 하드웨어는 정방향이 역방향보다 조금 더 빠르 때문인데 큰 차이는 아니다.
- 이러한 이유 때문에 정렬할 때 `filesort`가 발생하지 않아 정렬 시 극적인 성능 향상을 끌어낼 수 있고, 단일 컬럼 인덱스에선 이 역방향 스캔과 내림차순 인덱스 간의 성능 차이가 크지 않을 수 있지만, 다중 컬럼 인덱스(복합 인덱스)에선 이 내림차순 인덱스 설정을 성능을 대폭 향상시킬 수 있다.

## 주의할 점

- 인덱스는 읽기 성능을 크게 향상시키지만, **쓰기(INSERT/UPDATE/DELETE) 성능은 저하**될 수 있음.
- 불필요한 인덱스는 관리 오버헤드만 증가 → 주기적 점검 필요.
- 너무 작은 데이터셋(예: 수십 건)에서는 인덱스 대신 풀 테이블 스캔이 더 빠를 수도 있음.

## 인덱스 요약

- 인덱스 = DB 성능 최적화의 핵심
- 검색 성능을 **O(n) → O(log n)** 으로 개선
- WHERE / JOIN / ORDER BY 등에 자주 쓰이는 컬럼에 적용
- `EXPLAIN`으로 실행 계획을 반드시 점검

## 커버링 인덱스

- 커버링 인덱스는 인덱스를 생성할 때 인덱스 할 컬럼을 삽입해두고, 조회 시 인덱스에 있는 내용들로 조회 시 테이블을 거치지않고 인덱스 내부에서 바로 결과 값을 돌려주는 방식을 말한다.
- 예로 들어 :
```sql
create index idx_items_item_name on items (item_name);

...

select item_name from items where item_name = '노트북';
```

- 위 와 같이 `item_name`을 인덱스로 등록해두고, `select`할 때 `item_name`만 `select`하여 조회할 시 인덱스에 있는 내용을 조회하기에 `커버링 인덱스`를 할 수 있는 것이다.
- 이런 방식으로 인덱스 테이블에서 조회를 하지 않고 실제 테이블에서 조회하는 경우를 `일반 인덱스`라고 한다.

